defmodule MobupayWeb.TransactionController do
  use MobupayWeb, :controller

  alias Mobupay.Helpers.{Response, EC, Utility, Token, Pagination, CountryData}
  alias Mobupay.Services.Paystack
  alias Mobupay.Transactions
  alias Mobupay.Account

  require Logger

  # Matches request with no email address present in the payload
  def self_initiate(
        %Plug.Conn{
          assigns: %{current_user: %Mobupay.Account.User{email: email}}
        } = conn,
        _amount
      )
      when is_nil(email) do
    conn
    |> Response.error(
      400,
      "Please add your email address"
    )
  end

  # Handles card transactions
  def self_initiate(
        %Plug.Conn{
          assigns: %{
            current_user:
              %Mobupay.Account.User{country: country, email: email, msisdn: msisdn} = user
          }
        } = conn,
        %{"amount" => amount, "ip_address" => ip_address, "device" => device, "card" => card_ref} =
          params
      ) do
    Logger.info(
      "Received request for self account funding (old card) with params #{inspect(params)}"
    )

    with %Account.Card{authorization_code: authcode} <-
           Account.get_user_card_by_ref(user, card_ref),
         {:ok,
          %Transactions.Transaction{amount: transaction_amount, ref: reference} = transaction} <-
           Transactions.create_transaction(%{
             ref: Token.generate(:random),
             status: :initiated,
             type: :self_fund,
             msisdn: msisdn,
             amount: Utility.remove_decimal(amount),
             narration: "Self funding - autogenerated",
             ip_address: ip_address,
             device: device
           }),
         {:ok, :paystack, _paystack_data} <-
           paystack_charge_auth(%{
             email: email,
             amount: transaction_amount,
             authcode: authcode,
             reference: reference
           }),
         {:ok, %Transactions.Transaction{}} <-
           Transactions.update_transaction_status(transaction, :accepted),
         #  {:ok, %Transactions.Ledger{}} <- maybe_create_ledger_entry(transaction),
         new_balance <- Transactions.get_balance(user),
         {:ok, currency} <- CountryData.get_currency(country) do
      conn
      |> Response.ok(%{
        balance: new_balance,
        transaction_amount: transaction_amount,
        transaction_currency: currency,
        card: %{},
        channel: "authorization_token"
      })
    else
      {:error, :paystack, %{"data" => %{"gateway_response" => gateway_response}} = error_response} ->
        Logger.error("Paystack charge auth is failing with error: #{inspect(error_response)}")

        message =
          "E#{EC.get("unable_to_charge_authorization")} - Unable to charge card, please use another card!. Gateway Response: #{gateway_response}"

        conn
        |> Response.error(500, message)

      error ->
        Logger.error(
          "Error initiating paystack transaction (old card) with payload: #{inspect(params)} and error: #{inspect(error)}"
        )

        conn
        |> Response.error(
          500,
          "E#{EC.get("unhandled_charge_authorization_error")} - Unable to process transaction at the moment, please try again later."
        )
    end
  end

  # Handles requests with no card
  def self_initiate(
        %Plug.Conn{
          assigns: %{
            current_user: %Mobupay.Account.User{country: country, email: email, msisdn: msisdn}
          }
        } = conn,
        %{"amount" => amount, "ip_address" => ip_address, "device" => device} = params
      ) do
    Logger.info("Received request for self account funding with params #{inspect(params)}")

    amount = Utility.remove_decimal(amount)

    call_back_hash = Token.generate(60)

    case Paystack.initialize_transaction(%{
           amount: amount,
           email: email,
           callback: self_initiate_callback_url(msisdn, call_back_hash)
         }) do
      {:ok, %{"status" => true, "data" => %{"reference" => ref} = data}} ->
        Transactions.create_transaction(%{
          ref: ref,
          status: :initiated,
          type: :self_fund,
          msisdn: msisdn,
          amount: amount,
          narration: "Self funding - autogenerated",
          ip_address: ip_address,
          device: device
        })

        conn
        |> Response.ok(%{
          transaction: data,
          channel: "new_gateway"
        })

      error ->
        Logger.error(
          "do_self_funding/2 with bindings: #{inspect(binding())} failed with error: #{inspect(error)}"
        )

        conn
        |> Response.error(500, "An error occured while initiating payment")
    end
  end

  # Handles requests with invalid params
  def self_initiate(conn, _params) do
    conn
    |> Response.error(400, "Invalid/missing parameters")
  end

  defp self_initiate_callback_url(msisdn, hash) do
    System.get_env("MOBUPAY_FRONTEND_URL") <> "#{msisdn}/send/self-funding?consolidator=#{hash}"
  end

  def verify_transaction(
        %Plug.Conn{
          assigns: %{current_user: %Mobupay.Account.User{country: country} = user}
        } = conn,
        %{"ref" => ref, "consolidator" => consolidator} = params
      ) do
    with %Transactions.Transaction{amount: transaction_amount} = transaction <-
           Transactions.get_by_ref(ref),
         {:ok, :verified, paystack_data} <-
           verify_on_paystack(ref),
         {:ok, %Transactions.Transaction{}} <-
           Transactions.update_transaction_status(transaction, :accepted),
         #  {:ok, %Transactions.Ledger{}} <- maybe_create_ledger_entry(transaction),
         {:ok, card} <- maybe_save_card(user, paystack_data),
         new_balance <- Transactions.get_balance(user),
         {:ok, currency} <- CountryData.get_currency(country) do
      conn
      |> Response.ok(%{
        balance: new_balance,
        transaction_amount: transaction_amount,
        transaction_currency: currency,
        card: card
      })
    else
      nil ->
        conn
        |> Response.error(
          404,
          "E#{EC.get("transaction_not_found")} - Unable to verify transaction"
        )

      {:error, :not_verified} ->
        conn
        |> Response.error(
          400,
          "E#{EC.get("transaction_not_successful_on_paystack")} - Unable to verify transaction"
        )

      error ->
        Logger.error(
          "Error verifying paystack transaction with payload: #{inspect(params)} and error: #{inspect(error)}"
        )

        conn
        |> Response.error(
          500,
          "E#{EC.get("unhandled_transaction_verification_error")} - Unable to verify transaction"
        )
    end
  end

  def phone_number(conn, params) do
    Logger.info("Received request for phone number transfer with params #{inspect(params)}")

    conn
    |> Response.ok()
  end

  # List user transactions
  def transactions(
        %Plug.Conn{
          assigns: %{current_user: %Mobupay.Account.User{} = user}
        } = conn,
        params
      ) do
    transactions = Transactions.list_user_transactions(user, params)

    conn
    |> Response.ok(Pagination.format("transactions", transactions))
  end

  defp verify_on_paystack(ref) do
    case Paystack.verify_transaction(ref) do
      {:ok, %{"status" => true, "data" => %{"status" => "success"} = data}} ->
        {:ok, :verified, data}

      _ ->
        {:error, :not_verified}
    end
  end

  defp paystack_charge_auth(params) do
    do_charge_response = Paystack.charge_authorization(params)

    case do_charge_response do
      {:ok, %{"status" => true, "data" => %{"status" => "success"}}} ->
        {:ok, :paystack, do_charge_response}

      _ ->
        {:error, :paystack, do_charge_response}
    end
  end

  defp maybe_create_ledger_entry(transaction) do
    case Transactions.ledger_entry_exists?(transaction) do
      true ->
        {:ok, %Transactions.Ledger{}}

      false ->
        Transactions.create_ledger_entry(transaction)
    end
  end

  defp maybe_save_card(user, %{"channel" => "card", "authorization" => authorization}) do
    Account.create_card(user, authorization)
  end

  defp maybe_save_card(_user, _params), do: {:ok, %{}}
end
